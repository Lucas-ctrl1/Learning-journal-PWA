<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Journal - My Learning Journal</title>
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <!-- CSS LINK UPDATED FOR FLASK -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>

   <div class="container">
        <h1>Learning Journal</h1>
        <p class="subtitle">Documenting my journey through Mobile Application Development</p>

        <div class="journal-entry">
            <h2>Add New Journal Entry</h2>
            <form id="journal-form" class="journal-form">
                <div class="form-group">
                    <label for="entry-title">Title:</label>
                    <input type="text" id="entry-title" name="title" required placeholder="Enter entry title">
                </div>
                <div class="form-group">
                    <label for="entry-content">Content:</label>
                    <textarea id="entry-content" name="content" rows="5" required placeholder="Write your journal entry..."></textarea>
                </div>
                <div class="form-group">
                    <label for="entry-tags">Tags (comma separated):</label>
                    <input type="text" id="entry-tags" name="tags" placeholder="e.g., JavaScript, API, Learning">
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn-primary">Save Entry</button>
                </div>
            </form>
        </div>


<section class="export-section">
    <h3>ðŸ“¥ Export All Entries</h3>
    <p>Download all your journal entries (browser + Python) as a JSON file</p>
    <button id="export-btn" class="export-button">Export All Entries</button>
</section>

        <div class="journal-entry">
            <h2>Your Journal Entries</h2>
            <div id="journal-entries">
                </div>
        </div>

        <div class="journal-entry">
            <h2>ðŸŽ¬ Programming Videos</h2>
            <p>Related mobile development and programming videos from YouTube:</p>
            <button id="load-videos-btn" class="btn-primary">Load Latest Videos</button>
            <div id="youtube-videos" class="youtube-container">
                </div>
        </div>

        <article class="journal-entry">
    <h2>Week 7 - PWA & Offline Capabilities</h2>

    <div class="entry-content">

        <h3>1. Why is it useful to enhance your Flask app with PWA features?</h3>
        <p>Enhancing the Flask app with PWA features transforms it from a simple website into a reliable, app-like experience. By adding a Service Worker and Manifest, the app becomes installable on the user's home screen and works regardless of network status. This improves user engagement and reliability, bridging the gap between the reach of the web and the capabilities of native mobile apps.</p>

        <h3>2. What did you use to support offline access and dynamic data?</h3>
        <p>I used the <strong>Service Worker API</strong> acting as a network proxy to manage caching.</p>
        <ul>
            <li><strong>Static Assets:</strong> I used the <strong>install</strong> event to cache core files (HTML, CSS, JS) so the app shell loads instantly.</li>
            <li><strong>Dynamic Data:</strong> I implemented a "Stale-While-Revalidate" strategy for the <strong>/api/reflections</strong> route. This serves cached JSON data immediately if the user is offline, ensuring they can still read their journal entries without an internet connection.</li>
        </ul>

        <h3>3. What extra feature did you add, and why?</h3>
        <p>I implemented a <strong>Robust Offline Detection System</strong> with a "Heartbeat" monitor. While standard browser events detect when connection is lost, they can be glitchy on mobile. I added a <strong>setInterval</strong> check that pings the network status every 3 seconds. If the user goes offline, a Red Toast Notification appears, and the UI turns grayscale. I added this to provide clear, immediate visual feedback so the user knows why the app isn't syncing.</p>

        <h3>4. Did you face any challenges deploying your PWA, and how did you solve them?</h3>
        <p>Yes, I faced two main challenges:</p>
        <ul>
            <li><strong>Manifest Mismatch:</strong> The "Install" button wouldn't appear on my phone. I discovered my icon was a <strong>.jpg</strong> but my code expected a <strong>.png</strong>. Fixing the MIME type in <strong>manifest.json</strong> solved this.</li>
            <li><strong>Script Caching Issues:</strong> My navigation bar disappeared on the "About" page while offline. I realized I had a syntax error (missing quote) in the script tag in <strong>about.html</strong>, and the Service Worker was caching the broken version. I fixed the typo and bumped the Service Worker version to force a cache refresh, which brought the menu back.</li>
        </ul>
    </div>
</article>


        <!-- WEEK 6 - FLASK BACKEND INTEGRATION (NEW ENTRY) -->
<article class="journal-entry">
    <h2>Week 6 - Flask Backend & Live Deployment</h2>

    <div class="entry-content">

        <h3>1. Why is the frontend-backend connection important?</h3>
        <p>The frontend-backend connection is vital because it allows the application to be dynamic and persistent. The frontend (PWA) handles the user interface, while the backend (Flask) manages persistence by storing data externally on the server. This setup is crucial for data security, ensures the application works across all devices, and allows for complex server-side logic beyond what the browser can handle.</p>

        <h3>2. Which HTTP methods did you use in Flask, and why?</h3>
        <p>I used the two fundamental HTTP methods for API interaction in Flask: GET and POST.</p>
        <ul>
            <li><strong>GET /api/reflections:</strong> Used to retrieve data. The PWA sends a GET request when loading, and Flask responds by reading the entire <code>reflections.json</code> file and serving the data as JSON.</li>
            <li><strong>POST /api/reflections:</strong> Used to create/send data. The PWA sends the new journal entry via a POST request, allowing the Flask server to process the data, add a timestamp, and securely save the entry to the <code>reflections.json</code> file.</li>
        </ul>

        <h3>3. What is the difference between using Flask to store and load JSON data and reading JSON directly in the browser?</h3>
        <p>The primary difference is persistence and write access. Using Flask (Lab 6) ensures data is stored permanently on the PythonAnywhere server, and the server handles all writing/modifying of the file. Reading JSON directly in the browser (Lab 5) only works for displaying static data, as the browser's JavaScript cannot write to files on the hard disk for security reasons. Flask provides the necessary secure gateway to make the data truly live and shareable.</p>

        <h3>4. Did you face any difficulties when running your project on PythonAnywhere? How did you handle them?</h3>
        <p>Yes, the main difficulties involved routing and file access:</p>
        <ul>
            <li>Routing Issues: Flask is a single-page router, so when I clicked navigation links, the browser returned a 404 error because only the `/` route was initially defined. Solution: I added specific routes in "flask_app.py" for each page (e.g., journal,about and updated the JavaScript navigation to target these new routes.</li>
            <li>File Access: Ensuring Flask recognized the PWA assets required placing the HTML files in the <strong><code>templates</code></strong> folder and all CSS/JS files in the static folder. Furthermore, a Reload of the web app was necessary after every Python code change to see the updates.</li>
        </ul>

        <h3>5. What extra feature did you build into your PWA with Flask, and why did you add it?</h3>
        <p>I built a <strong>Dual-Persistence System with Selective Deletion</strong> that goes beyond basic Flask requirements. While the core lab focused on server-side storage, I implemented:</p>
        <ul>
            <li><strong>Local Browser Storage</strong> for instant saves and offline capability</li>
            <li><strong>Flask Server Storage</strong> for permanent cross-device persistence</li>
            <li><strong>Independent Delete Functionality</strong> for both storage systems</li>
        </ul>
        <p>This creates a robust, user-centric architecture where entries are saved in both systems simultaneously, but can be managed independently. Users can delete local entries without affecting server data, and vice versa, providing granular control and redundancy.</p>
        <p>I added this because it demonstrates professional-grade data management - showing understanding of fallback strategies, user experience, and production-ready application design that exceeds basic CRUD operations.</p>
    </div>
</article>



        <!-- Week 5 - PYTHON & JSON BACKEND DATA (NEW ENTRY) -->
        <article class="journal-entry">
            <h2>Week 5 - Python & JSON Backend Data</h2>

            <div class="entry-content">

                <h3>1. How is storing data in a JSON file different from using browser storage?</h3>
                <ul>
                    <li>Location and Access: The JSON file is stored on the local machine's disk or server and can be modified by external programs (like the Python script). Browser storage (Local Storage) is managed entirely by client-side JavaScript within the user's specific browser.</li>
                    <li>Scope: The JSON file provides data persistence outside the browser environment. Local Storage is tied to the browser origin and can be easily cleared by the user, making it less permanent for backend data.</li>
                    <li>Updatability: The JSON file is updated by a separate backend process (Python), whereas Local Storage is updated directly by the PWA's JavaScript.</li>
                    <li>Portability: JSON files can be easily exported, imported, and shared across systems, while browser storage is device-specific and not easily transferable.</li>
                </ul>

                <h3>2. How did you use Python to create or update your JSON file?</h3>
                <p>I used the Python script save_entry.py, combined with the built-in json and datetime modules for robust data handling.</p>
                <ol>
                    <li>The script first used <code>os.path</code> logic to ensure it could find <code>reflections.json</code> reliably.</li>
                    <li>It used <code>json.load()</code> to read the existing list of reflections.</li>
                    <li>It took the user's reflection via <code>input()</code> and appended the new entry (with a timestamp) to the list.</li>
                    <li>Finally, it used <code>json.dump()</code> to save the complete, updated list back to the file, making the changes persistent on the disk.</li>
                </ol>

                <h3>3. What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</h3>
                <p>They are not the same due to different execution environments.</p>
                <ul>
                    <li>Locally: The PWA displays a merged view of entries from both Local Storage and the dynamically updated reflections.json file. Users can add entries via both the web form and Python script, and export all data.</li>
                    <li>On GitHub Pages: Users only see entries from Local Storage and the static reflections.json file as it existed at the last commit. GitHub Pages cannot execute the Python script or write to files, making the JSON data read-only.</li>
                    <li>Reason: This demonstrates the fundamental difference between client-side persistence (Local Storage) and server-side file storage with backend processing capabilities.</li>
                </ul>

                <h3>4. What extra feature did you add to your PWA using the JSON file, and why?</h3>
                <p>I implemented a comprehensive <strong>Data Export System</strong> that leverages the JSON file structure.</p>
                <ul>
                    <li>Export Functionality: Added an "Export All Entries" button that downloads a complete backup of all journal data (both Local Storage entries and Python JSON entries) as a single JSON file.</li>
                    <li>Why this feature: This provides users with complete data ownership and portability. They can backup their learning journey, transfer entries between devices, or use the data for external analysis. It demonstrates practical use of JSON for data interchange.</li>
                    <li>Additional Features: Also included a Reflection Counter showing Python entries count and visual styling to distinguish between browser-saved and Python-saved entries, enhancing user awareness of the dual storage system.</li>
                </ul>
            </div>
        </article>

        <article class="journal-entry">
            <h2>Week 4 - Introduction to APIs</h2>

            <div class="entry-content">
                <h3>Which Storage, Browser, and Third-Party APIs did you choose, and why?</h3>
                <p>I chose the following APIs to enhance my Learning Journal PWA:</p>
                <ul>
                    <li><strong>Storage API:</strong> I selected <strong>Local Storage</strong> because it provides a simple and persistent way to save data on the user's device. This was ideal for saving both the user's <strong>journal entries</strong> and their <strong>dark mode theme preference</strong> across browser sessions, fulfilling a core persistence requirement of the lab.</li>
                    <li><strong>Browser API:</strong> I chose the <strong>Notifications API</strong> and the <strong>Clipboard API</strong>. The Notifications API allows for providing <strong>asynchronous feedback</strong> (e.g., confirming an entry was saved or deleted) without interrupting the user's workflow. The Clipboard API offers a modern, secure way to allow users to <strong>copy entry content</strong> with a single click, which significantly improves usability.</li>
                    <li><strong>Third-Party API:</strong> I integrated the <strong>YouTube Data API</strong> to display relevant programming and mobile development videos. This was chosen to integrate <strong>external educational content</strong> directly into the journal app, making it a more comprehensive learning resource.</li>
                </ul>

                <h3>How did you integrate each API with DOM manipulation?</h3>
                <p>Each API required careful integration with the Document Object Model (DOM):</p>
                <ul>
                    <li><strong>Local Storage:</strong> Integration involves listening for the form <strong>submit event</strong>. Upon submission, data is read from the form elements, formatted, and saved using `storage.saveEntry()`. When the page loads, `JournalApp.loadEntries()` <strong>retrieves all data</strong> and dynamically generates new HTML `div` elements, inserting them into the `#journal-entries` container to display the saved content.</li>
                    <li><strong>Browser APIs:</strong> The Notifications API is triggered via JavaScript calls to `browserAPI.showNotification()` after relevant user actions, ensuring the <strong>DOM remains clean</strong> while providing visual feedback. The Clipboard API is linked to the <strong>"Copy" buttons</strong> within each dynamically created entry, using an event listener to capture the entry's text content before calling `navigator.clipboard.writeText()`.</li>
                    <li><strong>YouTube API:</strong> A button click event triggers `JournalApp.loadYouTubeVideos()`, which fetches the data asynchronously. The app then manipulates the DOM by clearing the `#youtube-videos` container and <strong>dynamically inserting HTML cards</strong> containing the video title, channel, and thumbnail/link.</li>
                </ul>

                <h3>What challenges did you encounter, and how did you solve them?</h3>
                <p>The two primary challenges were API reliability and user permissions:</p>
                <ul>
                    <li><strong>Third-Party API Reliability/Quota Limits:</strong> The YouTube Data API has strict usage quotas, which risked the feature breaking if the quota was exceeded. <strong>Solution:</strong> I implemented robust <strong>error handling (`try...catch`)</strong> and created a `getDefaultVideos()` <strong>fallback mechanism</strong> in `thirdparty.js`. If the live API call fails, the app still loads and displays mock video content, ensuring the application remains functional.</li>
                    <li><strong>Notifications API Permissions:</strong> The browser requires explicit user permission to show notifications. <strong>Solution:</strong> I added a check in the `JournalApp.init()` method to gracefully <strong>request permission</strong> if it is still set to 'default', ensuring notifications only display after the user grants permission.</li>
                </ul>

                <h3>In what ways do these APIs improve your Learning Journal PWA?</h3>
                <p>The APIs dramatically improve the PWA in three key areas:</p>
                <ul>
                    <li><strong>Persistence & Reliability:</strong> Using Local Storage means the app no longer loses user data on reload or close, transforming it from a temporary tool into a <strong>reliable personal journal</strong>. The theme preference is also consistently loaded, improving the user experience.</li>
                    <li><strong>User Feedback & Interactivity:</strong> The Notifications and Clipboard APIs enhance the application's responsiveness. The PWA now provides <strong>immediate, clear feedback</strong> on actions and offers a quick utility (copying entries) that improves workflow and efficiency.</li>
                    <li><strong>Educational Value:</strong> The integration of the <strong>YouTube Data API</strong> turns the journal page into a <strong>contextual learning dashboard</strong>. By serving relevant programming videos, it supports the user's ongoing education directly within the application, enhancing its utility beyond simple note-taking.</li>
                </ul>
            </div>
        </article>

        <article class="journal-entry">
            <h2>Week 3 - JavaScript & DOM Manipulation</h2>

            <div class="entry-content">
                <h3>Which DOM selection methods did you use, and why did you choose them?</h3>
                <p>I used <strong>getElementById</strong> to target specific elements like the live date and dark mode toggle because it's fast and direct for single elements. I also used <strong>querySelector</strong> for more flexible element selection when needed.</p>

                <h3>What was the most challenging part about linking JavaScript with your HTML?</h3>
                <p>The most challenging part was ensuring the JavaScript loaded at the right time using <strong>DOMContentLoaded</strong> and making the reusable navigation work consistently across all pages without manual HTML duplication. Getting the dark mode toggle positioned correctly without overlapping content was also tricky.</p>

                <h3>How did you test and debug your JavaScript code?</h3>
                <p>I used <strong>console.log</strong> statements to check if elements were being selected properly and event listeners were working. I also used browser developer tools to test the dark mode CSS changes and fix positioning issues with the toggle button.</p>
            </div>
        </article>

          <article class="journal-entry">
            <h2>Week 2 - Frontend Fundamentals</h2>

            <div class="entry-content">
                <h3>How did you approach mobile-first design?</h3>
                <p>I started with mobile styles first, then used CSS media queries with min-width to enhance layouts for tablets and desktop screens.</p>

                <h3>What was the most useful HTML or CSS concept you applied this week?</h3>
                <p>CSS Flexbox for navigation and CSS Grid for project layouts were incredibly useful for responsive design.</p>

                <h3>What part of HTML or CSS did you find most challenging or confusing?</h3>
                <p>Making navigation consistent across pages without JavaScript was manual. Looking forward to automating this with components.</p>
            </div>
        </article>

        <article class="journal-entry">
            <h2>Week 1 - Introduction & PWA Foundations</h2>

            <div class="entry-content">
                <h3>Key Achievements:</h3>
                <p>Set up GitHub repository and VS Code integration. Built a Temperature Converter PWA with HTML, CSS, and JavaScript. Implemented core PWA features including web app manifest and service worker for offline functionality.</p>

                <h3>Multi-Platform Deployment:</h3>
                <p>Deployed the PWA to both GitHub Pages and PythonAnywhere for cross-platform testing. Also created my first Android mobile application in Android Studio, comparing PWA vs native development approaches.</p>

                <h3>Reflection:</h3>
                <p>Solid introduction to mobile development ecosystems. Experienced both web-based (PWA) and native (Android) development, understanding the strengths of each approach for different use cases.</p>
            </div>
        </article>
    </div>

    <!-- JAVASCRIPT LINKS UPDATED FOR FLASK -->
    <script src="{{ url_for('static', filename='js/storage.js') }}"></script>
    <script src="{{ url_for('static', filename='js/browser.js') }}"></script>
    <script src="{{ url_for('static', filename='js/thirdparty.js') }}"></script>
    <script src="{{ url_for('static', filename='js/journal-app.js') }}"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
     
